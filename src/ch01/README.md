# Chapter 01 - 첫 번째 예시

설계가 나쁜 시스템은 수정하기 어렵다. 원하는 동작을 수행하도록 하기 위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기 어렵기 때문이다. 무엇을 수정해야 할지 찾기 어렵다면, 실수로 인한 버그가 발생할 가능성이 높다.

> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링 한 뒤 원하는 기능을 추가한다.

# 새로운 요구사항 대응을 위한 리팩토링

다음과 같은 요구 사항이 추가되었다고 가정하자:
1. 청구내역을 HTML로 출력
2. 공연료와 적립 포인트 계산법

## 1. 청구내역을 HTML로 출력
이 요구사항은 어느 부분에 영향을 주게 될까?

청구 결과 각각에 HTML 태그 삽입을 위하여 문자열을 추가하는 문장 각각을 조건문으로 감싸야 한다. `statement()` 함수의 복잡도가 크게 증가할 것이다.

대부분의 경우, `statement()` 함수의 복사본을 만들고, 복사본에서 HTML을 출력하는 식으로 처리할 것이다. 이러한 방식은 수많은 문제를 일으킬 수 있는데,

**청구서 작성 로직을 변경할 때 마다 기존함수와 HTML 버전 함수 모두 수정하고, 일관되게 수정했는지 여부를 확인해야한다.**

## 2. 공연료와 적립 포인트 계산법
배우들은 많은 장르를 연기하고 싶어 하기 때문에, 장르가 추가됨에 따라 공연료와 적립 포인트 계산법이 변경될 것이다. 연극 장르와 공연료 정책이 달라질 때 마다 `statement()` 함수를 수정해야 한다. 1과 연관지어 생각한다면 HTML 버전의 함수를 추가적으로 생성한 경우 이 두 가지의 정책 수정이 매번 일관성을 가져야 하는데, 복잡함이 증대함은 물론 실수할 가능성이 농후하다.

# 결론
위와 같은 변경 사항 때문에 리팩터링이 필요하다. 또한 누군가 코드를 읽게 될 때, 이해하기 어렵다면 대책은 더더욱 필요하다.

---

# 첫 단계
## 테스트 코드 작성
리팩터링에서 테스트의 역할은 굉장히 중요하다. 프로그램이 클수록 예상치 못한 문제가 발생할 수 있고 실제 사람이 수행하기 때문에 리팩토링 과정에서 실수가 발생할 수 있다.

> 리팩터링을 하기 전, 제대로 된 테스트를 작성한다.


---
임시 변수는 나중에 문제를 일으킬 수 있다. 임시변수는 자신이 속한 루틴에서만 의미가 있어서 루틴이 길고 복잡해지기 쉽다.

따라서 리팩터링 시 이러한 임시 변수를 제거해야한다.

---
cho1 리팩터링 단계
1. **반복문 쪼개기**로 변수 값을 누적시키는 부분을 분리한다.
2. **문장 슬라이드하기**로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
3. **함수 추출하기**로 적립 포인트 계산 부분을 별도 함수로 추출한다.
4. **변수 인라인하기**로 volumeCredits 변수를 제거한다.